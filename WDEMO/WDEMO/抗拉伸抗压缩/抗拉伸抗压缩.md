#抗拉伸抗压缩


HuggingPriority和CompressionResistance 一个例子教你理解
https://www.jianshu.com/p/5cf559435eb9

>我取名 setContentHuggingPriority为 “抗拉伸”（这个名字我自己认为比较准确）；setContentCompressionResistancePriority 取名为“抗压缩”，接下来有个小例子,里面解释的也是挺详细的


```
UILabel * label = [[UILabel alloc]init];
  [self.view addSubview:label];
  label.backgroundColor = [UIColor yellowColor];
  
  UILabel * label2 = [[UILabel alloc]init];
  [self.view addSubview:label2];
  label2.backgroundColor = [UIColor blueColor];
  
  
  /*
   * intrinsicContentSize: 这个是label 的真实的 大小size
   * 抗拉伸 和 抗压缩 都是相对于intrinsicContentSize 值来说的
   **/
  
  
#if 0
  /*
   * 抗拉伸
   * 主要用在
   * eg：label、label2 限制后 还有空余空间，这个时候就需要谁来拉伸了，才能满足我们的限制
   * setContentHuggingPriority（值越高，越不容易拉伸，所以我取名为‘抗拉伸’）
   **/
  label.text = @"label";
  label2.text = @"label2";
  /*
   * 保证label 不被拉伸，那么只能拉伸label2
   **/
  [label setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];
  [label2 setContentHuggingPriority:UILayoutPriorityDefaultLow forAxis:UILayoutConstraintAxisHorizontal];

#else
  /*
   * 抗压缩
   * 主要用在
   * eg：label、label2 限制后 ，没有空余空间，这个时候就 只能压缩某个label，才能满足我们的限制
   * setContentCompressionResistancePriority（值越高，越不容易压缩，所以我取名为‘抗压缩’）
   **/
  label.text = @"hello，我是第一个label，请多多！";
  label2.text = @"hello，我是第二个label，谢谢";
  /*
   * 保证label2 不被压缩，那么只能压缩label
   **/
  [label setContentCompressionResistancePriority:UILayoutPriorityDefaultLow forAxis:UILayoutConstraintAxisHorizontal];
  [label2 setContentCompressionResistancePriority:UILayoutPriorityDefaultHigh forAxis:UILayoutConstraintAxisHorizontal];
  
#endif
  
  [label mas_makeConstraints:^(MASConstraintMaker *make) {
     
      make.left.equalTo(@10);
      make.top.equalTo(@10);
      make.right.equalTo(label2.mas_left).offset(-20);
  }];
  
  [label2 mas_makeConstraints:^(MASConstraintMaker *make) {
     
      make.left.equalTo(label.mas_right).offset(20);
      make.top.equalTo(label);
      make.right.equalTo(@(-10));
  }];

```




iOS Masonry label自适应 以及 scrollview 和masonry混用的注意点
https://www.jianshu.com/p/7a5be9f46b1d

masonry 下UILabel 宽度自适应
```
1.自适应宽度前提不需要设置label的宽度//
宽度够时
[yourLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];
宽度不够时
[yourLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];
2.label多行自适应高度
label.preferredMaxLayoutWidth = width;//给一个maxWidth
[label setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
//设置huggingPriority
label.numberOfLines = 0;//设置换行
```
UIScrollView 和masonry 混用的时候可能会出现约束方面的问题，最好是给UIScrollView的子视图设定好宽度。



用masonry自适应label高度和宽度
https://blog.csdn.net/qq_38641559/article/details/104751731
```
hugging 这个约束条件，会尽可能压缩视图，使其紧贴内容；
compression resistance 这个约束条件，会尽可能向外扩大视图，是内容尽可能不会被裁剪。

Content Compression Resistance = 不许挤我！

对，这个属性说白了就是“不许挤我”=。=
这个属性的优先级（Priority）越高，越不“容易”被压缩。也就是说，当整体的空间装不下所有的View的时候，Content Compression Resistance优先级越高的，显示的内容越完整。

Content Hugging = 抱紧！

这个属性的优先级越高，整个View就要越“抱紧”View里面的内容。也就是View的大小不会随着父级View的扩大而扩大。一般用于 UILabel 之类的控件。

```
