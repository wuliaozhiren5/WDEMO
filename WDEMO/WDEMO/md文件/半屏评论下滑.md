
iOSTableview 禁止下拉,允许上拉
https://www.cnblogs.com/sunfuyou/p/7131474.html
```
-(void)scrollViewDidScroll:(UIScrollView *)scrollView
{
NSLog(@"%f",tableV.contentOffset.y);
if (tableV.contentOffset.y <= 0) {
  tableV.bounces = NO;

  NSLog(@"禁止下拉");
}
else
if (tableV.contentOffset.y >= 0){
  tableV.bounces = YES;
  NSLog(@"允许上拉");

}
}
```
```
- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
CGPoint offset = tableV.contentOffset;
if (offset.y <= 0) {
    offset.y = 0;
}
tableV.contentOffset = offset;
}
```


iOS tableView添加手势冲突解决办法
https://www.jianshu.com/p/96d689af0b2f
```
1、在tableView上添加手势，并设置手势代理为当前控制器
2、利用代理方法- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer 允许tableView上响应多手势
3、利用代理方法- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer，控制添加的手势是否响应

通常在tableView上添加手势，会有冲突，比如在tableView上添加pan手势，就会让tableView的无法滚动，在tableViewCell上添加tap手势，就会让tableViewCell的didSelectCell方法无法响应等等，利用代理方法 gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer: 虽然能让添加的手势和原来的事件都响应，但是会造成一次性响应多个事件，这时候就需要用代理方法gestureRecognizerShouldBegin:来控制，添加的手势是否需要响应，并且不会阻断事件传递，这样就能很好的解决冲突问题。
```


iOS 拖动手势（UIPanGestureRecognizer）
https://www.jianshu.com/p/e318943549c7
```
/* 解决手势冲突问题
 * 1、当设置水平拖动时，手势竖直拖动距离大于手势水平拖动距离时，此手势不响应
 2、当拖动到最小值时，再往左拖动，不响应
 3、当拖动到最大值时，再往右拖动，不响应
 4、竖直逻辑同水平
 */
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
{
    UIView *view = gestureRecognizer.view;
    if ([gestureRecognizer isKindOfClass:[UIPanGestureRecognizer class]]) {
        CGPoint offset = [(UIPanGestureRecognizer *)gestureRecognizer translationInView:view];
        if (self.panDerection == JYCPanDerectionHorizontal && (fabs(offset.y) >= fabs(offset.x))) {
            return NO;
        }
        if (self.panDerection == JYCPanDerectionHorizontal && ((view.frame.origin.x == self.minX && offset.x < 0) ||  (view.frame.origin.x == self.maxX && offset.x > 0)) ) {
            return NO;
        }
        if (self.panDerection == JYCPanDerectionVertical && (fabs(offset.x) >= fabs(offset.y))) {
            return NO;
        }
        
        if (self.panDerection == JYCPanDerectionVertical && ((view.frame.origin.y == self.minY && offset.y < 0) ||  (view.frame.origin.y == self.maxY && offset.y > 0)) ) {
            return NO;
        }
        return YES;
    }
    return YES;
}
```


iOS 拖动手势(UIPanGestureRecognizer)
https://www.jianshu.com/p/b6099e9d0d5b
```
//添加手势
UIPanGestureRecognizer *panGesture = [UIPanGestureRecognizer new];
panGesture.delegate = self;
[view addGestureRecognizer:panGesture];

//代理--手势识别器是否能够开始识别手势.
当手势识别器识别到手势,准备从UIGestureRecognizerStatePossible状态开始转换时.调用此代理,如果返回YES,那么就继续识别,如果返回NO,那么手势识别器将会将状态置为UIGestureRecognizerStateFailed.

- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)gestureRecognizer {
    CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view];
    
    //相对有手势父视图的坐标点(注意如果父视图是scrollView,locationPoint.x可能会大于视图的width)
    CGPoint locationPoint = [gestureRecognizer locationInView:gestureRecognizer.view];
    
    
    if (translation.x < 0) {
        //向左滑
        NSLog(@"向左滑");
    }else if (translation.x > 0) {
        //向右滑
        NSLog(@"向右滑");
    }
    
    if (translation.y < 0) {
        //向上滑
        NSLog(@"向上滑");
    }else if (translation.y > 0) {
        //向下滑
        NSLog(@"向下滑");
    }
    return NO;
}
```


IOS简单拖拽手势实现
https://www.cnblogs.com/eric-zhangy1992/p/11394417.html
```
1.创建手势并添加到相应试图上

UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pangesture:)];

 [self.mSliderView addGestureRecognizer:pan];

2.实现手势事件

/**

     *  获取手势按下的地方

     */

    CGPoint panGesturePoint = [gesture translationInView:self.mSliderView];

    

    /**

     * 处理像左/像右拖拽事件

     */

    if (panGesturePoint.x < 0) {

        [self transitionView:gesture.view];

    } else {

        gesture.view.center = CGPointMake(gesture.view.center.x + panGesturePoint.x, gesture.view.center.y);

    }

     /**

     * 手势结束和失败时处理方式

     */

    if (gesture.state == UIGestureRecognizerStateFailed || gesture.state == UIGestureRecognizerStateEnded) {

        /**

         * 试图向右拖拽超过试图本身一般位置时，关闭筛选试图；否则返回单初始位置

         */

        if (gesture.view.center.x <= (kSizeScreenWidth / 2 + 60 + ((kSizeScreenWidth - 60) / 2))) {

           ...  回退动作

        } else {

          ...  关闭动作

        }

    }

    /**

     * 清空位移数据，避免拖拽事件的位移叠加

     */

    [gesture setTranslation:CGPointZero inView:gesture.view];
```


locationInView 和translationInView这个两个方法的区别
https://blog.csdn.net/majiakun1/article/details/50656392
```
locationInView:获取到的是手指点击屏幕实时的坐标点；
translationInView：获取到的是手指移动后，在相对坐标中的偏移量
```

=========================

